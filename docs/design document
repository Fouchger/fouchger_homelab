Design Document

## Target structure
```
fouchger_homelab/
  README.md
  VERSION

  bootstrap.sh                     # Entry point users run (from anywhere)
  homelab.sh                       # Repo entry wrapper (calls menu)

  bin/
    menu.sh                        # The dialog UI menu (main controller)
    lib/
      ui.sh                        # dialog helpers, theme, common widgets
      log.sh                       # logging helpers
      os.sh                        # OS detection + minimal package install
      perms.sh                     # chmod + executable enforcement
      validate.sh                  # input validation (IP, tokens, etc.)
      config.sh                    # load/save config

  config/
    settings.env                   # persisted config (non-secret)
    secrets.env.example            # template only (never commit secrets.env)
    profiles.yml                   # predefined profiles -> app lists
    apps.yml                       # app catalogue, install/uninstall handlers
    proxmox.env.example            # example for Proxmox auth details

  state/
    selections.env                 # persisted selections (generated)
    logs/
      homelab.log

  modules/
    apps/
      install/                     # scripts called by apps.yml
        docker.sh
        tailscale.sh
        nfs.sh
        vscode-server.sh
      uninstall/
        docker.sh
        tailscale.sh
        nfs.sh
        vscode-server.sh

    proxmox/
      setup_access.sh              # create role/user/token (via pve API/CLI)
      download_templates.sh         # Ubuntu 22.04+ LXC + Talos latest
      terraform/
        main.tf
        variables.tf
        outputs.tf
        versions.tf
        providers.tf
        modules/
          lxc/
          vm/
      ansible/
        ansible.cfg
        inventory/
          proxmox_dynamic.yml       # optional
          hosts.ini                 # fallback
        playbooks/
          site.yml
          base.yml
          k8s_talos.yml
        roles/
          common/
          hardening/
          docker/
          monitoring/

  docs/
    ADRs/
    runbooks/
```

## Design intent:

- bootstrap.sh is the only thing you run manually. It installs the bare minimum: `git` (or `curl` + `tar` if you prefer), `dialog`, and CA certs. Then it clones the repo and hands off to `homelab.sh`.
- `bin/menu.sh` is the single source of truth for user workflow. Everything else is a module invoked by the menu.
- Executable permissions are enforced in one place (`bin/lib/perms.sh`) and run after download and before menu.


Below is an expanded, end-to-end project flow diagram plus a clear “function to file” reference so every menu option has an obvious implementation path and supporting files.

## Expanded structure

```text
fouchger_homelab
├── config
│ ├── apps.yml
│ ├── executables.list
│ ├── profiles.yml
│ ├── proxmox.env.example
│ ├── secrets.env.example
│ ├── settings.env
│ ├── validations.yml
│ └── ui.yml
├── docs
│ ├── ADRs
│ ├── developers
│ ├── runbooks
│ └── users
├── lib
│ ├── common.sh
│ ├── config.sh
│ ├── env.sh
│ ├── logger.sh
│ ├── ui_dialog.sh
│ ├── validation.sh
│ └── runtime.sh
├── commands
│ ├── menu.sh
│ ├── selections.sh
│ ├── profiles.sh
│ ├── apps_install.sh
│ ├── apps_uninstall.sh
│ ├── proxmox_access.sh
│ ├── templates.sh
│ ├── terraform_apply.sh
│ ├── ansible_apply.sh
│ ├── diagnostics.sh
│ └── cleanup.sh
├── modules
│ └── apps
│ ├── install
│ │ └── docker.sh
│ └── uninstall
│ └── docker.sh
├── proxmox
│ ├── ansible
│ │ ├── inventory
│ │ │ ├── hosts.yml
│ │ │ └── proxmox_dynamic.yml
│ │ ├── playbooks
│ │ │ ├── base.yml
│ │ │ ├── k8s_talos.yml
│ │ │ └── site.yml
│ │ ├── roles
│ │ │ ├── common
│ │ │ ├── docker
│ │ │ ├── hardening
│ │ │ └── monitoring
│ │ └── ansible.cfg
│ ├── terraform
│ │ ├── modules
│ │ │ ├── lxc
│ │ │ └── vm
│ │ ├── main.tf
│ │ ├── outputs.tf
│ │ ├── providers.tf
│ │ ├── variables.tf
│ │ └── versions.tf
│ ├── download_templates.sh
│ └── setup_access.sh
├── state
│ ├── cache
│ │ ├── repo
│ │ ├── templates
│ │ └── terraform
│ ├── logs
│ ├── runs
│ │ └── latest.env
│ ├── selections.env
│ ├── proxmox.env
│ └── secrets.env
├── .gitignore
├── LICENSE
├── README.md
├── VERSION
├── bootstrap.sh
└── homelab.sh
```


**Notes on what’s new and why**
* lib is the shared plumbing (UI, logging, env handling, validation), so every command behaves consistently.
* commands is the contract: one file per menu action. homelab.sh routes to these.
* state/cache and state/runs keep artefacts tidy and avoid re-downloading templates or re-initialising Terraform unnecessarily.
* config/validations.yml and config/ui.yml keep rules and UI behaviour declarative, so extending the menu doesn’t turn into a bash spaghetti situation.

## Project flow diagram (with file references)

```flow
flowchart TD
  A[User runs bootstrap.sh] --> B[bootstrap: install minimum deps + clone repo]
  B --> C[bootstrap: mark executables]
  C --> D[handoff to homelab.sh]

  D --> E[load runtime + config + env]
  E --> F[open dialog menu]
  F --> G{Menu selection}

  G --> H1[Select profile]
  H1 --> I1[Merge/replace selections]
  I1 --> F

  G --> H2[Manual select apps to install]
  H2 --> I2[Persist selections]
  I2 --> J2[Run installers]
  J2 --> F

  G --> H3[Manual select apps to uninstall]
  H3 --> I3[Persist selections]
  I3 --> J3[Run uninstallers]
  J3 --> F

  G --> H4[Setup Proxmox user/role/token]
  H4 --> I4[Write proxmox.env]
  I4 --> F

  G --> H5[Download LXC/VM templates]
  H5 --> I5[Cache templates]
  I5 --> F

  G --> H6[Provision LXC/VM with Terraform]
  H6 --> I6[terraform init/plan/apply]
  I6 --> F

  G --> H7[Configure with Ansible]
  H7 --> I7[dynamic inventory + site.yml]
  I7 --> F

  G --> H8[Diagnostics]
  H8 --> I8[validate env + show logs]
  I8 --> F

  G --> Z[Exit]
  ```

### iagram to file mapping

- A: bootstrap.sh
- B: bootstrap.sh, lib/runtime.sh, lib/common.sh
- C: config/executables.list, lib/validation.sh (optional checks), bootstrap.sh
- D: homelab.sh
- E: lib/runtime.sh, lib/config.sh, lib/env.sh, lib/logger.sh, config/settings.env, state/proxmox.env, state/secrets.env
- F: commands/menu.sh, lib/ui_dialog.sh, config/ui.yml
- H1: commands/profiles.sh, config/profiles.yml, config/apps.yml
- I1: commands/selections.sh, state/selections.env, lib/config.sh
- H2: commands/apps_install.sh, commands/selections.sh, config/apps.yml
- J2: modules/apps/install/*.sh, lib/common.sh, lib/logger.sh
- H3: commands/apps_uninstall.sh, commands/selections.sh, config/apps.yml
- J3: modules/apps/uninstall/*.sh, lib/common.sh, lib/logger.sh
- H4: commands/proxmox_access.sh, proxmox/setup_access.sh, config/proxmox.env.example, state/proxmox.env
- H5: commands/templates.sh, proxmox/download_templates.sh, state/cache/templates
- H6: commands/terraform_apply.sh, proxmox/terraform/*, state/cache/terraform, state/logs
- H7: commands/ansible_apply.sh, proxmox/ansible/inventory/, proxmox/ansible/playbooks/site.yml, proxmox/ansible/roles/
- H8: commands/diagnostics.sh, lib/validation.sh, config/validations.yml, state/logs

### “Required for every function” baseline (the consistent contract)

1. Every command in commands should source the same core set so behaviour is uniform:
- lib/runtime.sh (paths, OS detection, dependency checks, run context)
- lib/logger.sh (structured logs to state/logs, plus console output)
- lib/ui_dialog.sh (dialog wrappers, standard colours, window sizing)
- lib/env.sh (load state/proxmox.env, state/secrets.env, config/settings.env safely)
- lib/config.sh (read config/apps.yml and config/profiles.yml consistently)
- lib/validation.sh (pre-flight checks based on config/validations.yml)

### This gives you the “single look and feel” you asked for, plus predictable error handling.

Function reference (menu option to implementation)

Select profile (basic, development, network admin, proxmox admin)

UI and routing: commands/menu.sh, lib/ui_dialog.sh

Profile definitions: config/profiles.yml

App catalogue and metadata: config/apps.yml

Merge/replace logic and persistence: commands/profiles.sh, commands/selections.sh, state/selections.env

Manual select apps to install or uninstall

UI and selection: commands/apps_install.sh, commands/apps_uninstall.sh

Execution: modules/apps/install/<app>.sh and modules/apps/uninstall/<app>.sh

Logging: lib/logger.sh to state/logs

Setup Proxmox user/role/token

Menu handler: commands/proxmox_access.sh

Proxmox script: proxmox/setup_access.sh

Output env: state/proxmox.env (seeded from config/proxmox.env.example)

Download Proxmox LXC/VM templates (Ubuntu 22+ and latest Talos)

Menu handler: commands/templates.sh

Downloader: proxmox/download_templates.sh

Cache: state/cache/templates

Setup LXC/VM using Terraform

Menu handler: commands/terraform_apply.sh

Terraform code: proxmox/terraform/*

Terraform working/cache: state/cache/terraform

Outputs passed forward: proxmox/terraform/outputs.tf plus state/runs/latest.env

Configure LXC/VM using Ansible

Menu handler: commands/ansible_apply.sh

Inventory: proxmox/ansible/inventory/hosts.yml and proxmox_dynamic.yml

Playbooks: proxmox/ansible/playbooks/site.yml (calls base.yml etc.)

Roles: proxmox/ansible/roles/*

Emerging risks and opportunities to bake in now

Conventional, low-risk

Add config/validations.yml gates so Terraform cannot run unless Proxmox creds exist and templates are present. This avoids half-built environments and rework.

Use state/runs/latest.env to pass artefacts between steps cleanly (for example, Terraform outputs to Ansible inventory vars).

Innovative but practical

Add a “dry run mode” toggle in config/settings.env that runs validations, shows intended changes, and writes a plan report into state/logs without touching Proxmox.

Add a “replay last run” option using state/runs/latest.env so you can reproduce a build quickly, useful for homelab rebuilds and disaster recovery.